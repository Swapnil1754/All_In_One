import { __decorate, __metadata, __param } from "tslib";
import { Pipe, Optional, Inject } from '@angular/core';
import { FileInputConfig, NGX_MAT_FILE_INPUT_CONFIG } from '../model/file-input-config.model';
var ByteFormatPipe = /** @class */ (function () {
    function ByteFormatPipe(config) {
        this.config = config;
        this.unit = config ? config.sizeUnit : 'Byte';
    }
    ByteFormatPipe.prototype.transform = function (value, args) {
        if (parseInt(value, 10) >= 0) {
            value = this.formatBytes(+value, +args);
        }
        return value;
    };
    ByteFormatPipe.prototype.formatBytes = function (bytes, decimals) {
        if (bytes === 0) {
            return '0 ' + this.unit;
        }
        var B = this.unit.charAt(0);
        var k = 1024;
        var dm = decimals || 2;
        var sizes = [this.unit, 'K' + B, 'M' + B, 'G' + B, 'T' + B, 'P' + B, 'E' + B, 'Z' + B, 'Y' + B];
        var i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    };
    ByteFormatPipe.ctorParameters = function () { return [
        { type: FileInputConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGX_MAT_FILE_INPUT_CONFIG,] }] }
    ]; };
    ByteFormatPipe = __decorate([
        Pipe({
            name: 'byteFormat'
        }),
        __param(0, Optional()),
        __param(0, Inject(NGX_MAT_FILE_INPUT_CONFIG)),
        __metadata("design:paramtypes", [FileInputConfig])
    ], ByteFormatPipe);
    return ByteFormatPipe;
}());
export { ByteFormatPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnl0ZS1mb3JtYXQucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1tYXQtZmlsZS1pbnB1dC8iLCJzb3VyY2VzIjpbImxpYi9waXBlL2J5dGUtZm9ybWF0LnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEUsT0FBTyxFQUFFLGVBQWUsRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBSzlGO0lBR0Usd0JBR1UsTUFBdUI7UUFBdkIsV0FBTSxHQUFOLE1BQU0sQ0FBaUI7UUFFL0IsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUNoRCxDQUFDO0lBRUQsa0NBQVMsR0FBVCxVQUFVLEtBQVUsRUFBRSxJQUFVO1FBQzlCLElBQUksUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUIsS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN6QztRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVPLG9DQUFXLEdBQW5CLFVBQW9CLEtBQWEsRUFBRSxRQUFpQjtRQUNsRCxJQUFJLEtBQUssS0FBSyxDQUFDLEVBQUU7WUFDZixPQUFPLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQ3pCO1FBQ0QsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ2YsSUFBTSxFQUFFLEdBQUcsUUFBUSxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFNLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDbEcsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwRCxPQUFPLFVBQVUsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0UsQ0FBQzs7Z0JBdEJpQixlQUFlLHVCQUY5QixRQUFRLFlBQ1IsTUFBTSxTQUFDLHlCQUF5Qjs7SUFMeEIsY0FBYztRQUgxQixJQUFJLENBQUM7WUFDSixJQUFJLEVBQUUsWUFBWTtTQUNuQixDQUFDO1FBS0csV0FBQSxRQUFRLEVBQUUsQ0FBQTtRQUNWLFdBQUEsTUFBTSxDQUFDLHlCQUF5QixDQUFDLENBQUE7eUNBQ2xCLGVBQWU7T0FOdEIsY0FBYyxDQTZCMUI7SUFBRCxxQkFBQztDQUFBLEFBN0JELElBNkJDO1NBN0JZLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtLCBPcHRpb25hbCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWxlSW5wdXRDb25maWcsIE5HWF9NQVRfRklMRV9JTlBVVF9DT05GSUcgfSBmcm9tICcuLi9tb2RlbC9maWxlLWlucHV0LWNvbmZpZy5tb2RlbCc7XG5cbkBQaXBlKHtcbiAgbmFtZTogJ2J5dGVGb3JtYXQnXG59KVxuZXhwb3J0IGNsYXNzIEJ5dGVGb3JtYXRQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gIHByaXZhdGUgdW5pdDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChOR1hfTUFUX0ZJTEVfSU5QVVRfQ09ORklHKVxuICAgIHByaXZhdGUgY29uZmlnOiBGaWxlSW5wdXRDb25maWdcbiAgKSB7XG4gICAgdGhpcy51bml0ID0gY29uZmlnID8gY29uZmlnLnNpemVVbml0IDogJ0J5dGUnO1xuICB9XG5cbiAgdHJhbnNmb3JtKHZhbHVlOiBhbnksIGFyZ3M/OiBhbnkpOiBhbnkge1xuICAgIGlmIChwYXJzZUludCh2YWx1ZSwgMTApID49IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5mb3JtYXRCeXRlcygrdmFsdWUsICthcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRCeXRlcyhieXRlczogbnVtYmVyLCBkZWNpbWFscz86IG51bWJlcikge1xuICAgIGlmIChieXRlcyA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwICcgKyB0aGlzLnVuaXQ7XG4gICAgfVxuICAgIGNvbnN0IEIgPSB0aGlzLnVuaXQuY2hhckF0KDApO1xuICAgIGNvbnN0IGsgPSAxMDI0O1xuICAgIGNvbnN0IGRtID0gZGVjaW1hbHMgfHwgMjtcbiAgICBjb25zdCBzaXplcyA9IFt0aGlzLnVuaXQsICdLJyArIEIsICdNJyArIEIsICdHJyArIEIsICdUJyArIEIsICdQJyArIEIsICdFJyArIEIsICdaJyArIEIsICdZJyArIEJdO1xuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGspKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCgoYnl0ZXMgLyBNYXRoLnBvdyhrLCBpKSkudG9GaXhlZChkbSkpICsgJyAnICsgc2l6ZXNbaV07XG4gIH1cbn1cbiJdfQ==